## 哈希表
## 哈希函数
1. 哈希函数经过哈希计算过的值是个非负数
2. 如果 key1 != key2 那么 hash(key1) != hash(key2)
3. 如果 key1 == key2 那么 hash(key1) == hash(key2)
    <p> 但是在世纪钟 第2 条几乎是不可能的，无法完全避免哈希冲突 
## 哈希冲突
- 解决哈希冲突的方法
1. 开放寻址法
   - 核心思路是：冲突时，重新探测新位置，
   - 重新探测新位置的方法有线性探测（如果冲突，从当前位置开始遍历直到找到空位置）和二次探测（与线性的探测不同是，探测的步长的变化，线性是每个元素遍历，他是0，1^2，2^2）、双哈希法
2. 链表法
   - 每个哈希槽 slot 对应一个链表，链表中存放hash 值相等的元素

## 负载因子
负载因子 k = n/m ,n是hash 表中元素个数，m 是哈希槽slot的个数<br/>
如果k 过大说明元素过多 冲突的可能概率变大，插入和删除、查询元素的性能会随之下降
<p>hash 的动态扩容,当负载因子要超过设定值的时候可以动态扩容，搬运元素到新hash表中，</p>
**设定的阈值太大会导致hash冲突性能下降，阈值太小又会频繁扩容 浪费空间**


## 避免低效的扩容
处理办法经常是 当达到了阈值之后直接创建新的hash表，并不会搬运元素，当有新元素进来后再搬运一次旧的元素

## 解决hash 冲突
1. 开发寻址法：数据量较小负载因子小的时候适合，比如ThreadLocalMap
2. 链表法：数据量大，负载因子接近于1，缺点消耗较多的内存

## hash 表实现LRU 缓存
1. 链表 头部存放最近访问元素，尾部存放最早访问，记录头指针和尾指针 方便回收和操作
2. hash表：使用hash 表做为索引 来提高链表的查询效率