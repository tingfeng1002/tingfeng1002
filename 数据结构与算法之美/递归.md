## 递归函数示范
Recursion

```go
func f(n int) int {
	if n == 1 {
		return 1
	}
	return f(n-1) + 1
}

```

## 满足递归的三个条件
1、求解问题可以拆解成几个子问题的解决
2、子问题的求解思路是一致的
3、存在终止条件


## 举例
n 级的台阶 ，每一步可以可以是走一台阶 和走俩台阶 总共多少种走法，<br/>
1. 分析：假设 第一级有1种类走法 那么总共走法是 f(n-1)+f(1) 类推 n 级走法是f(n) = f(n-1) + f(n-2)
2. 找到终止条件 f(1) =1 第一节别就不需要走 只有1 种走法，实际是 1 层阶级确实是2 种，所以需要f(0) =1 ，但是 实际上不存在0 所以更改下终止条件 f(2) =2

```go 

func f(n int) int {
    if n== 1{
        return 1
    }  
    if n==2{
        return 2
    }
    
    return f(n-1) + f(n-2)
}
```

## 编写递归的难点
如果A 问题可以分解成子问题B,子问题C和子问题D ,在编写递归代码时候，我们假设BCD 已经解决<br/>
在此基础上思考如何解决问题A，而不需要思考A 与BCD之间的关系，<br/>
**屏蔽递归细节** 不要用人脑分解递归步骤，总结递推共识写递归代码

## 堆栈溢出
允许的最大递归深度与当前线程的栈空间有关，无法事先计算

### 尾递归
尾递归主要是为了防止栈溢出，但不能完全防止 ，只能是有可能

```go
// 普通的阶乘 递归函数
func f(n int ) int {
    if n== 1{
        return 1
    }
    return f(n-1) *n 
}

// 改成尾递归
func f(n ,res int ) int {
    if n <= 1{
        return res
    }
    // 这样做 可以将 n-1 压入 新函数的栈 并不需要返回地址
    return f(n-1,n* res)
}

```
