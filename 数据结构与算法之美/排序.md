## 排序算法的执行效率
- 时间复杂度的最好 最坏 和平均
- 时间复杂度的 系数项与常数项
    <br/> 实际开发中 要排序的数据量可能比较小，所以要比较系数与常数项
- 比较元素和交换元素的次数
    <br/> 比较元素的复杂度远小于交换元素的复杂度

## 稳定排序与不稳定排序
- 区别： 稳定排序是 假设有重复的数据 在排序后 重复数据的顺序并不会发生变化，<br/>
    实际使用中 一般是订单按照金额排序 金额相等的再按照 时间排序，稳定排序的思路：先按照时间排序，排序后在调用金额排序，经过两遍稳定排序 保证顺序不会发生改变

## 排序算法分类

O(n^2) : 冒泡排序，插入排序，选择排序
O(n*log n) : 快速和归并排序
O(n):桶排序  基数排序 计数排序

## 冒泡排序
- 概念： 进行n 次冒泡操作 每次冒泡都依次比较相邻元素的大小是否满足要求，不满足则交换顺序
- 实现
```go
func bubblesort(array []int) []int {
	count := len(array)
	for i := 0; i < count; i++ {
		for j := 0; j < count-1-i; j++ {
			if array[j] > array[j+1] {
				array[j] ,array[j+1] = array[j+1], array[j]
			}
		}
	}
	return array
}
```
- 优化项
当某次冒泡操作没有数据操作时候 标识可以提前退出循环
- 问答
1. 冒泡排序是原地排序算法吗 是整个交换过程中只涉及到与旁边数据的交换 属于原地排序
2. 是稳定排序吗

## 插入排序
- 概念：在插入新元素时候与原有元素进行比较，找到自己合适的位置
- 实现：
```

func insertsort (array [] int ) [] int {
	if len(array) <=1 {
		return array
	}

	for i := 1; i < len(array); i++ {
		back := array[i]
		j := i-1
		for  j>=0 && back < array[j]{
			array[j+1] = array[j]
			j--
		}
		array[j+1] = back
	}
	return array
}

```