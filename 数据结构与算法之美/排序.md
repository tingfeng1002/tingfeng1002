## 排序算法的执行效率
- 时间复杂度的最好 最坏 和平均
- 时间复杂度的 系数项与常数项
    <br/> 实际开发中 要排序的数据量可能比较小，所以要比较系数与常数项
- 比较元素和交换元素的次数
    <br/> 比较元素的复杂度远小于交换元素的复杂度

## 稳定排序与不稳定排序
- 区别： 稳定排序是 假设有重复的数据 在排序后 重复数据的顺序并不会发生变化，<br/>
    实际使用中 一般是订单按照金额排序 金额相等的再按照 时间排序，稳定排序的思路：先按照时间排序，排序后在调用金额排序，经过两遍稳定排序 保证顺序不会发生改变

## 排序算法分类

O(n^2) : 冒泡排序，插入排序，选择排序
O(n*log n) : 快速和归并排序
O(n):桶排序  基数排序 计数排序

## 冒泡排序
- 概念： 进行n 次冒泡操作 每次冒泡都依次比较相邻元素的大小是否满足要求，不满足则交换顺序
- 实现
```go
func bubblesort(array []int) []int {
	count := len(array)
	for i := 0; i < count; i++ {
		for j := 0; j < count-1-i; j++ {
			if array[j] > array[j+1] {
				array[j] ,array[j+1] = array[j+1], array[j]
			}
		}
	}
	return array
}
```
- 优化项
当某次冒泡操作没有数据操作时候 标识可以提前退出循环
- 问答
1. 冒泡排序是原地排序算法吗 是整个交换过程中只涉及到与旁边数据的交换 属于原地排序
2. 是稳定排序吗

## 插入排序
- 概念：在插入新元素时候与原有元素进行比较，找到自己合适的位置
- 实现：
```

func insertsort (array [] int ) [] int {
	if len(array) <=1 {
		return array
	}
	for i := 1; i < len(array); i++ {
		back := array[i]
		j := i-1
		for  j>=0 && back < array[j]{
			array[j+1] = array[j]
			j--
		}
		array[j+1] = back
	}
	return array
}

```
- 问题
 排序需要额外空间并不是原地排序  是稳定排序

## 选择排序

- 概念：分为排序区和未排序区，与插入排序不同的是 每次从未排序区选择最小的数字放入排序区末尾 
- 实现

```java
class Test {
    public void selectSort(int[] array) {

        int length = array.length;
        // 最后一次不需要排序
        for (i =0;i<length-1;i++){
            int minPos = i
            for (j=i+1;j<length;j++){
                if (array[j]< array[i]){
                    // 找到最小下标
                    minPos = j;
                }
            }
            // 交换元素
            int temp = array[i];
            array[i] = array[minPos];
            array[minPos] = temp;
        }
    }
}

```

原地排序 时间复杂度 固定为O(n^2)