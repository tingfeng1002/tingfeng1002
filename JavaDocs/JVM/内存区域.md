## 运行时内存划分
- 方法区(Method Area)（线程共享）
- 堆（Heap）(线程共享）
- 程序计数器 （Program Counter Register） 线程私有
- 虚拟机栈（VM stack）线程私有
- 本地方法栈（Native Method stack） 线程私有

## 程序计数器
是一块较小的内存空间，可以看作当前线程所执行字节码的行号指示器。<br/>
字节码届时器工作时通过改变计数器的值来获取下一条所需要直接的字节码指令，它是程序控制流的指示器，分支 循环 跳转 异常处理 线程恢复都需要程序计数器

## 虚拟机栈
虚拟机栈是线程级别的栈内存，每当线程内调用一个函数时候存放一个栈帧（stack frame）同步存入或者出栈<br/>
栈帧（stack frame）由局部变量表，操作数栈，动态链接，方法出口等信息组成<br/>
局部变量表存放是方法的局部变量，主要由基本类型 byte boolean short int float long double 与 应用类型组成，应用类型存放是指向对象的指针或者是指针开始位置等，<br/>
局部变量表是使用局部变量槽（Slot）存储元素信息的，每个槽的大小不一致，由JVM 与操作系统决定 除了long 与double 占用两个槽<br/>
**局部变量表的大小实在编译时期已经完成的**

### 内存区域的异常
- 线程请求的栈深度大于虚拟机允许的深度 StackOverflowError
- 如果虚拟机栈可以动态扩展，当栈扩展是无法申请到足够的内存就会抛出OutOfMemoryError

## 地方法栈
与虚拟机栈作用类似，区别只是虚拟机栈为虚拟机执行Java 方法，本地方法栈执行本地Native 方法

## Java 堆
**被线程共享的一块内存区域，主要的作用时存放对象实例** <br/>
**几乎所有的对象和数组都应当在堆上分配** 由于JIT 技术的进步，尤其是逃逸技术分析的强大，栈上分配，标量替换的优化手段导致发生了一些变化，并不是所有的对象都在堆
<p>垃圾回收器大多数基于分代收集理论，**所以会经常出现 年轻代 老年代 永久代 Eden 空间等 这里的内存区域划分仅仅是一部分垃圾回收器共同的特性和设计风格，并不是JVM 固定的内存布局**</p>

### TLAB
在所有线程共享的堆中划分出多个线程私有的分配缓冲区 （TLAB）,用来提升分配效率

<p> 堆可以是固定大小 也可以是动态扩展 可以使用参数-Xmx -Xms 设定，</p>

### 堆与物理空间
堆可以处在不连续的物理空间中 但是使用的逻辑上被视作连续的


## 方法区
各个线程共享，主要存储被虚拟机加载的类型信息，常量 ，静态常量，即使编译后的代码缓存等数据
<p>Jdk7前hostpot 使用永久代实现方法区，这样直接可以使用堆的垃圾回收器来回收方法区，之后 使用本地内存 元空间来实现，把主要的类型信息移动到元空间</p>
方法区主要存储类的相关信息，比如类名，访问控制符，字段描述，常量，一些CGLIB 框架动态代理的类越多就会在方法区存储越来越多的类型信息，方法区内存不足会跑出OOM:PremGen Space

### 运行时常量池
运行时常量池是方法区的一部分。class文件中除了 版本、字段、方法、接口等信息外还有是常量池表，用于存放编译期生成的各种字面量和符号引用，这部分内容在累加载后存放到方法区的运行时常量池中

## 直接内存
直接内存并不属于虚拟机，由于引入NIO 类和基于Channel与Buffer 的IO 方式，可以直接使用Native 方法直接在堆外分配内存，然后通过Java 堆中的DirectByteBuffer 对象作为这块内存的引用进行数据操作<br/>
直接内存可以通过-XX:MaxDirectMemorySize 来制定，不指定的话和堆一样大小，申请直接内存也会抛出内存溢出，但并不是向操作系统申请内存的一样，而是通过计算得知内存不够


