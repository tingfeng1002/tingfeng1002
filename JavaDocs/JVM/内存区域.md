## 运行时内存划分
- 方法区(Method Area)（线程共享）
- 堆（Heap）(线程共享）
- 程序计数器 （Program Counter Register） 线程私有
- 虚拟机栈（VM stack）线程私有
- 本地方法栈（Native Method stack） 线程私有

## 程序计数器
是一块较小的内存空间，可以看作当前线程所执行字节码的行号指示器。<br/>
字节码届时器工作时通过改变计数器的值来获取下一条所需要直接的字节码指令，它是程序控制流的指示器，分支 循环 跳转 异常处理 线程恢复都需要程序计数器

## 虚拟机栈
虚拟机栈是线程级别的栈内存，每当线程内调用一个函数时候存放一个栈帧（stack frame）同步存入或者出栈<br/>
栈帧（stack frame）由局部变量表，操作数栈，动态链接，方法出口等信息组成<br/>
局部变量表存放是方法的局部变量，主要由基本类型 byte boolean short int float long double 与 应用类型组成，应用类型存放是指向对象的指针或者是指针开始位置等，<br/>
局部变量表是使用局部变量槽（Slot）存储元素信息的，每个槽的大小不一致，由JVM 与操作系统决定 除了long 与double 占用两个槽<br/>
**局部变量表的大小实在编译时期已经完成的**

### 内存区域的异常
- 线程请求的栈深度大于虚拟机允许的深度 StackOverflowError
- 如果虚拟机栈可以动态扩展，当栈扩展是无法申请到足够的内存就会抛出OutOfMemoryError

## 地方法栈
与虚拟机栈作用类似，区别只是虚拟机栈为虚拟机执行Java 方法，本地方法栈执行本地Native 方法

## Java 堆
**被线程共享的一块内存区域，主要的作用时存放对象实例** <br/>
**几乎所有的对象和数组都应当在堆上分配** 由于JIT 技术的进步，尤其是逃逸技术分析的强大，栈上分配，标量替换的优化手段导致发生了一些变化，并不是所有的对象都在堆
<p>垃圾回收器大多数基于分代收集理论，**所以会经常出现 年轻代 老年代 永久代 Eden 空间等 这里的内存区域划分仅仅是一部分垃圾回收器共同的特性和设计风格，并不是JVM 固定的我内存布局**</p>

### TLAB
在所有线程共享的堆中划分出多个线程私有的分配缓冲区 （TLAB）,用来提升分配效率

<p> 堆可以是固定大小 也可以是动态扩展 可以使用参数-Xmx -Xms 设定，</p>

### 堆与物理空间
堆可以处在不连续的物理空间中 但是使用的逻辑上被视作连续的
