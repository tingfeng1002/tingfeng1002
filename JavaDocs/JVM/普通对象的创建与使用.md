## 普通对象 
不包括Class ，数组对象，指的是普通的new

## 创建过程
1. 检查指令参数能否在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否被加载、解析和初始化。没有则必须进行类加载
2. 如果类加载过则分配空间给创建的对象，java 堆划分一部分给对象一般有两种方式，指针碰撞法、空闲列表法。具体使用那种取决于Java 堆是否规整，Java 堆是否规整取决于垃圾回收器是否具有压缩整理能力
- 指针碰撞法：将空间分为两部分：已经使用和未使用,中间使用指针隔离。分配过程中需要将指针移动
- 空闲列表法：将可用的内存记录在列表中，当分配空间时从列表中移除该记录
- 分配内存过程中的线程冲突是如何解决的，虚拟机一般是通过cas + 重试来解决，另一种方案是TLAB 线程本地分配缓冲区，在堆中开劈一块专属于线程的分配空间用来分配，当TLAB 不够用时候再去加锁扩容
3. 内存分配完成之后,虚拟机必须将分配到的空间（对象头除外）都初始化0值，如果是TLAB 则在分配期间完成
4. java 虚拟机对对象进行必要的设置，比如是那个类的实例，如何找到类的元数据信息，对象的哈希code（会延迟到真正调用Object::hashcode 方法时候才会计算）,gc 分代年龄信息。这些信息存放到对象头中
5. 执行构造函数,即执行Class 文件中的<init>()方法，一般来说new 指令之后会执行<init>方法，

## 对象的内存布局

对象在堆中内存主要分为三个部分：
- 对象头，Header
- 实例数据，Instance Data
- 对齐填充 Padding

### 对象头
对象头一般存放两部分数据
- 对象自身运行时数据，如HashCode,GC分代年龄、锁标志位、线程持有锁、偏向锁id,偏向时间戳，这一类数据官方称为Mark Word,未开启指针压缩时候在32和64位虚拟机中占用32bit和64bit。因为运行时候数据较多超出了64bitmap 所持范围，所以MarkWorld 设计成复用的
  <p>在无锁32bit 默认情况下使用25bit 存储hashcode,4bit 存储分代年龄，2 bit 存储锁标志，1bit 固定0</p>
- 另一部分数据是指向对象类型元数据的指针，通过该指针来确定是那个类的实例

### 实例数据
实例数据是对象真正存储有效信息，即我们代码中所定义的各种字段的内容，无论是父类继承还是子类中定义的字段都必须记录起来

## 对齐填充
占位符的作用，因为虚拟机内存管理要求对象的大小必须是8字节的整数倍

## 对象的使用
Java 程序通过栈上的reference 数据来操作堆上具体对象，Reference 只是定义为为对象的引用，具体实现在不同虚拟机有不同的实现，主流的有如下两种
- 语句柄
在堆中构建语句柄池，栈中reference 指向语句柄，语句柄在存储对象实际地址和对象类型信息，这样的好处是在GC 回收过程中只需要更改语句柄的指向即可

- 直接地址
栈中使用地址直接指向堆对象，在对象中保存指向类信息的指针，好处就是速度快


## 内存溢出（OutOfMemoryError）
首先要判断是内存泄漏还是内存溢出，泄漏指的是无法回收一些对象，需要从GCRoots开始分析，溢出指的是查处xmx 堆配置


