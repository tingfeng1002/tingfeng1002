# 内存回收

## 回收那些空间
1. 在运行中，程序计数器、虚拟机栈、本地方法栈随着想成的创建而创建，也随线程的消亡而消亡，并且方法的栈帧 基本上是确定大小的，在类结构确定后 大小基本确定
2. 整个垃圾回收主要的区域是堆和方法区

## 对象已死

### 引用计数
在对象中添加一个引用计数器，当对象被引用时候增加1，对象不被引用时候减少1，当对象不再引用就可以代表回收了。但是在主流的JVM 中并不真正的使用到该算法<br/>
比如对象ObjA，ObjB 中都拥有属性 instance 指向 对方，其实这两个不再被使用，但依旧回收不了
### 可达性分析法
通过被称为"GC Roots"的对象做为起点集，从这些点开始根据引用关系向下搜索，搜索走过的路径成为引用链（Reference Chain）,如果某个对象与GC Roots 没有任何的引用链 或者说从GC Roots 到该对象不可达，则证明该对象不再被使用

#### GC Roots
- 虚拟机栈中引用的对象，比如当前运行的参数，局部变量，临时变量
- 方法区中静态属性引用的对象
- 方法区中常量引用的对象，比如字符串常量
- JNI 中引用的变量
- 虚拟机内部引用，比如Class 对象，异常信息，类加载器
- 同步锁（syschronized） 持有对象
- 反映Java 虚拟机内存情况的JMXBean,本地代码缓存等

除了固定的GC Roots 外还有一些根据垃圾回收器和回收区域临时的性加入的对象，共同组建成GC Roots