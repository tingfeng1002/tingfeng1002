## 单例模式
- 定义： 保证一个类仅有一个实例，并提供一个访问它的全局访问点
- 实现：懒汉模式，饿汉模式，双重检查，静态内部类，枚举单例等
## 工厂模式
提供创建者与访问这隔离
###  简单工厂
- 定义：也称为静态工厂,也是编码中常用到的,提供工厂类，将具体实例的功能放到工厂类
- 实现：

```java
interface Product {
    void test();
}

class ProductA implements Product {
    @Override
    public void test() {
        System.out.println("A test");
    }
}
class ProductB implements Product {
    @Override
    public void test() {
        System.out.println("B test");
    }
}
class ProductFactory{
    public static Product getProduct(String type){
        if ("A".equals(type)){
            return new ProductA();
        }else {
            return new ProdyctB();
        }
    }
}
```
- 缺点： 每增加一种产品都需要更改ProductFactory中getProduct 方法,不满足开闭原则

### 工厂方法
- 定义：抽象产品工厂获取产品的方法，给每一类产品都创建工厂类，这样再创建新产品时候不需要更改代码，只需要新增对应产品与产品工厂就行</br>
       也就是让子类决定将哪一个类实例
- 实现：

```java
interface ProductFactory {
    Product getProduct();
}

class ProductAFactory implements ProductFactory {
    @Override
    public Product getProduct() {
        return new ProductA();
    }
}
class ProductBFactory implements ProductFactory {
    @Override
    public Product getProduct() {
        return new ProductB();
    }
}
// 使用,可以直接创建工厂或者使用匿名内部类
class Test{
    public static void main(String[] args) {
        ProductFactory productFactory = new ProductBFactory();
        Product product =productFactory.getProduct();
        product.test();
    }
}
```
- 缺点： 每个产品都有自己的产品工厂类，使得类比较多和使用不方便，但是满足迪米特法则与开闭原则
### 抽象工厂
- 定义：提供创建一系列产品工厂的高级工厂，比如产品体系中既有电脑又有平板，可以抽象一个产品工厂生产这两个产品，将两个产品的实例话延迟到子工厂，好比联想组装工厂</br>
  通俗来说是在工厂方法上再次抽象，增加其他类型的产品方法
- 实现：

```java
// 电脑
interface Computer {
}

// 手机
interface Phone {
}

interface ProductFactory {
    Computer getComputer();

    Phone getPhone();
}

// 联想组装工厂
class LenovoFactory implements ProductFactory {
    @Override
    public Computer getComputer() {
        return new Computer() {
            // 联想笔记本
        };
    }

    @Override
    public Phone getPhone() {
        // 联想手机
        return null;
    }
}
// 当然可以实现其他产品体系的工厂
```
## 建造者模式

- 定义：将一个复杂对象的构造与它的表示分离，是同样的构建过程可以创建不同的表示

- 实现：

  ```java
  class Product{
    private String partA;
    private String partB;
    private String partC;
  }
  
  abstract class ProductBuilder{
    product Product product = new Product();
    abstract void buildPartA();
    public Product build(){
      return product;
    }
    //....
  }
  class DefaultProductBuild extends ProductBuilder {
    private void buildPartA(){
      product.setPartA("PartA")
    }
    // ...
  }
  
  class Director {
    public static void main (String [] args) {
      ProductBuilder builder = new DefaultProductBuild();
      build.buildPartA();
      build.build();
    }
  }
  ```

  - 优缺点：可以描述创建过程，更改后实现链式调用

## 原型模式
- 定义： 使用已经创建的对象为原型，复制该原型来创建一个相似或者相同的对象
- 实现：使用Java的cloneable 接口并实现clone 方法
## 小总结：

- 一般构建简单对象使用工厂模式，复杂对象使用构建者模式，需要重复使用对象提升性能使用原型模式



